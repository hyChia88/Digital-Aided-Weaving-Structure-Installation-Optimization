import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error
import random
import matplotlib.pyplot as plt
from itertools import permutations
from tqdm import tqdm

class BendingActiveOptimizer:
    def __init__(self, tags_data, displacement_data, built_values):
        """
        Initialize the optimizer with assembly sequences and displacement data.
        
        Parameters:
        - tags_data: Dictionary mapping sequence IDs to assembly sequences
        - displacement_data: Dictionary mapping sequence IDs to displacement values at each step
        - built_values: Dictionary mapping rods to their ease-of-control scores
        """
        self.tags_data = tags_data
        self.displacement_data = displacement_data
        self.built_values = built_values
        self.model = None
        self.X_encoded = None
        self.y_scores = None
        
    def encode_sequences(self):
        """
        Encode assembly sequences using built_values and extract features.
        """
        X_encoded = []
        sequence_ids = []
        
        for seq_id, sequence in self.tags_data.items():
            # Encode sequence using built_values
            encoded_seq = [self.built_values.get(rod, 0) for rod in sequence]
            
            # Add sequence length as a feature
            seq_length = len(sequence)
            
            # Calculate other features from displacement data
            displacements = self.displacement_data.get(seq_id, [])
            if not displacements:
                continue
                
            # Displacement trend features
            max_displacement = max(displacements)
            avg_displacement = sum(displacements) / len(displacements)
            displacement_variance = np.var(displacements) if len(displacements) > 1 else 0
            
            # Rate of displacement reduction (slope between first and last point)
            if len(displacements) > 1:
                displacement_slope = (displacements[-1] - displacements[0]) / (len(displacements) - 1)
            else:
                displacement_slope = 0
                
            # Combine all features
            features = encoded_seq + [seq_length, max_displacement, avg_displacement, 
                                      displacement_variance, displacement_slope]
            
            X_encoded.append(features)
            sequence_ids.append(seq_id)
            
        # Create a feature matrix
        self.X_encoded = np.array(X_encoded)
        self.sequence_ids = sequence_ids
        
        return self.X_encoded
    
    def calculate_stability_scores(self):
        """
        Calculate stability scores based on displacement behavior.
        Lower scores indicate better stability during assembly.
        """
        stability_scores = []
        
        for seq_id in self.sequence_ids:
            displacements = self.displacement_data.get(seq_id, [])
            if not displacements:
                continue
                
            # Calculate stability score (lower is better)
            # Factors: maximum displacement, variance, area under curve
            max_disp = max(displacements)
            variance = np.var(displacements) if len(displacements) > 1 else 0
            area = sum(displacements)
            
            # Combined score (weighted sum)
            score = 0.5 * max_disp + 0.3 * variance + 0.2 * area
            stability_scores.append(score)
            
        self.y_scores = np.array(stability_scores)
        return self.y_scores
    
    def train_model(self, test_size=0.2, random_state=42):
        """
        Train a Random Forest model to predict stability scores.
        """
        if self.X_encoded is None:
            self.encode_sequences()
            
        if self.y_scores is None:
            self.calculate_stability_scores()
            
        # Split data into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(
            self.X_encoded, self.y_scores, test_size=test_size, random_state=random_state
        )
        
        # Train Random Forest model
        self.model = RandomForestRegressor(n_estimators=100, random_state=random_state)
        self.model.fit(X_train, y_train)
        
        # Evaluate model
        train_predictions = self.model.predict(X_train)
        test_predictions = self.model.predict(X_test)
        
        train_mae = mean_absolute_error(y_train, train_predictions)
        test_mae = mean_absolute_error(y_test, test_predictions)
        
        print(f"Training MAE: {train_mae:.4f}")
        print(f"Testing MAE: {test_mae:.4f}")
        
        return self.model
    
    def generate_candidate_sequences(self, num_samples=10000, max_rods=16):
        """
        Generate candidate sequences using permutation sampling.
        
        Parameters:
        - num_samples: Number of sequences to generate
        - max_rods: Maximum number of rods in the structure
        
        Returns:
        - List of candidate sequences
        """
        # Get unique rods from the existing sequences
        all_rods = set()
        for sequence in self.tags_data.values():
            all_rods.update(sequence)
        
        rod_list = list(all_rods)
        if len(rod_list) > max_rods:
            rod_list = rod_list[:max_rods]  # Limit to max_rods if needed
            
        # Generate random permutations
        candidate_sequences = []
        
        # If feasible, generate all permutations
        if len(rod_list) <= 8:  # Small enough for full enumeration
            all_perms = list(permutations(rod_list))
            # Sample if too many
            if len(all_perms) > num_samples:
                candidate_sequences = random.sample(all_perms, num_samples)
            else:
                candidate_sequences = all_perms
        else:
            # Random sampling for large sets
            seen = set()
            pbar = tqdm(total=num_samples, desc="Generating candidate sequences")
            
            while len(candidate_sequences) < num_samples:
                # Generate a random permutation
                candidate = tuple(random.sample(rod_list, len(rod_list)))
                
                # Only add if not seen before
                if candidate not in seen:
                    candidate_sequences.append(candidate)
                    seen.add(candidate)
                    pbar.update(1)
            
            pbar.close()
                
        return [list(seq) for seq in candidate_sequences]
    
    def predict_optimal_sequence(self, num_candidates=10000):
        """
        Predict the optimal assembly sequence from candidate sequences.
        
        Parameters:
        - num_candidates: Number of candidate sequences to evaluate
        
        Returns:
        - The predicted optimal sequence
        - Predicted stability score
        """
        if self.model is None:
            print("Model not trained yet. Training now...")
            self.train_model()
            
        # Generate candidate sequences
        candidates = self.generate_candidate_sequences(num_candidates)
        
        # Prepare features for each candidate
        candidate_features = []
        
        for sequence in tqdm(candidates, desc="Encoding candidates"):
            # Encode sequence using built_values
            encoded_seq = [self.built_values.get(rod, 0) for rod in sequence]
            
            # Add placeholder values for other features
            # These will be updated by the model prediction
            seq_length = len(sequence)
            placeholder_features = [0, 0, 0, 0]  # Placeholders for displacement features
            
            features = encoded_seq + [seq_length] + placeholder_features
            candidate_features.append(features)
            
        # Ensure consistent feature length by padding if necessary
        max_feature_len = max(len(features) for features in candidate_features)
        padded_features = []
        
        for features in candidate_features:
            if len(features) < max_feature_len:
                padded = features + [0] * (max_feature_len - len(features))
                padded_features.append(padded)
            else:
                padded_features.append(features)
                
        # Convert to numpy array
        X_candidates = np.array(padded_features)
        
        # Predict stability scores
        predicted_scores = self.model.predict(X_candidates)
        
        # Find the best sequence
        best_idx = np.argmin(predicted_scores)
        best_sequence = candidates[best_idx]
        best_score = predicted_scores[best_idx]
        
        print(f"Best predicted score: {best_score:.4f}")
        print(f"Optimal sequence: {best_sequence}")
        
        return best_sequence, best_score
    
    def visualize_optimal_sequence(self, sequence, title="Predicted Optimal Assembly Sequence"):
        """
        Visualize the predicted optimal assembly sequence.
        """
        # Create a plot showing the assembly order
        plt.figure(figsize=(12, 6))
        
        # Plot sequence as a step chart
        x = list(range(1, len(sequence) + 1))
        y = [self.built_values.get(rod, 0) for rod in sequence]
        
        plt.step(x, y, where='mid', marker='o', linestyle='-', linewidth=2)
        
        plt.title(title)
        plt.xlabel("Assembly Step")
        plt.ylabel("Rod Control Value")
        plt.grid(True, linestyle='--', alpha=0.7)
        
        # Add rod labels
        for i, rod in enumerate(sequence):
            plt.text(i + 1, y[i], rod, ha='center', va='bottom')
            
        plt.tight_layout()
        return plt.gcf()  # Return the figure for saving if needed

# Example usage (commented out as actual data would be needed)
import importlib.util
file_path = r"Installation Sequences Optimization\Structure Simulations\SimulationDataset.py"

spec = importlib.util.spec_from_file_location("SimulationDataset", file_path)
SimulationDataset = importlib.util.module_from_spec(spec)
spec.loader.exec_module(SimulationDataset)

tags_data = SimulationDataset.tags_data
displacement_data = SimulationDataset.data

built_values = {'#0':1,'#1':0.8387,'#2':0.7903,'#3':0.7419,'#4':0.6935,'#5':0.5645,'#6':0.5161,
                '#7':0.3225,'#8':0.3870,'#9':0.4838,'#10':0.1612,'#11':0.2258,'#12':0.0645,
                '#13':0.5483,'#14':0.8064,'#15':0.4193}

"""
# Sample data (would be replaced with actual data)
tags_data = {
    'seq1': ['rod1', 'rod2', 'rod3', 'rod4'],
    'seq2': ['rod2', 'rod1', 'rod3', 'rod4'],
    # More sequences...
}

displacement_data = {
    'seq1': [0.5, 0.3, 0.2, 0.0],
    'seq2': [0.8, 0.6, 0.4, 0.0],
    # More displacement data...
}

built_values = {
    'rod1': 0.8,
    'rod2': 0.6,
    'rod3': 0.9,
    'rod4': 0.7,
    # More rod values...
}
"""
# Initialize optimizer
optimizer = BendingActiveOptimizer(tags_data, displacement_data, built_values)

# Train model
optimizer.train_model()

# Predict optimal sequence
optimal_sequence, score = optimizer.predict_optimal_sequence(num_candidates=1000)

# Visualize
fig = optimizer.visualize_optimal_sequence(optimal_sequence)
plt.show()
